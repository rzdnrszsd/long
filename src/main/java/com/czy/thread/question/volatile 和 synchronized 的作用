Java Memory Model

并发编程中的两个问题：
一、线程之间如何通信 ？wait();notify();notifyAll();
    1、共享内存-隐式通信
    2、消息传递-显示通信 

二、线程之间如何同步


 java多线程中的原子性、可见性、有序性
  （1）、原子性：是指线程的多个操作是一个整体，不能被分割，要么就不执行，要么就全部执行完，中间不能被打断。
  （2）、可见性：是指线程之间的可见性，就是一个线程修改后的结果，其他的线程能够立马知道。
  （3）、有序性：为了提高执行效率，java中的编译器和处理器可以对指令进行重新排序，重新排序会影响多线程并发的正确性，
           有序性就是要保证不进行重新排序（保证线程操作的执行顺序）。

volatile关键字的作用：
    其实volatile关键字的作用就是保证了可见性和有序性（不保证原子性），如果一个共享变量被volatile关键字修饰，那么如果一个线程修改了这个共享变量后，
    其他线程是立马可知的。为什么是这样的呢？比如，线程A修改了自己的共享变量副本，这时如果该共享变量没有被volatile修饰，
    那么本次修改不一定会马上将修改结果刷新到主存中， 如果此时B去主存中读取共享变量的值，那么这个值就是没有被A修改之前的值。
    如果该共享变量被volatile修饰了，那么本次修改结果会强制立刻刷新到主存中， 如果此时B去主存中读取共享变量的值，那么这个值就是被A修改之后的值了。
    volatile能禁止指令重新排序，在指令重排序优化时，在volatile变量之前的指令不能在volatile之后执行，在volatile之后的指令也不能在volatile之前执行，
    所以它保证了有序性

synchronized关键字的作用：
    synchronized提供了同步锁的概念，被synchronized修饰的代码段可以防止被多个线程同时执行，必须一个线程把synchronized修饰的代码段都执行完毕了，
    其他的线程才能开始执行这段代码。因为synchronized保证了在同一时刻，只能有一个线程执行同步代码块，所以执行同步代码块的时候相当于是单线程操作了，
    那么线程的可见性、原子性、有序性（线程之间的执行顺序）它都能保证了。
 

volatile 和 synchronized 的作用以及两者的区别是什么？ 
     volatile仅能使用在变量上，synchronize可以使用在变量和方法上。
     volatile只能保证变量的可见性和有序性，不能保证变量的原子性，而synchronized都可以
     volatile不会造成线程阻塞，而synchronized会造成线程阻塞
     volatile标记的变量不会被编译器优化（因为不能指令重排），synchronized标记的变量可以被编译器优化；
     volatile修饰变量适合于一写多读的并发场景，而多写场景一定会产生线程安全问题
     因为所有的操作都需要同步给内存变量，所以volatile一定会使线程的执行速度变慢。
         https://www.cnblogs.com/kaleidoscope/p/9506018.html
