

Java基础相关：

    1、HashMap和Hashtable的区别。
        1、Hashtable是基于Dictionary类的，HashMap是Map接口的一个实现类

        2、Hashtable是线程安全的，即是同步的；HashMap线程不是安全的，不是同步的。

        3、HashMap可以将空值作为key或value

    2. HashMap、LinkedHashMap、TreeMap的区别。
        1、HashMap是根据键的hashcode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，取得的数据完全是随机的

        2、LinkedHashMap保存了记录的插入顺序，在使用Iterator进行遍历的时候，先得到的肯定是先插入的数据，
           可以在构造时带参数，按照应用次数来进行排序

        3、TreeMap实现SortMap接口，能够把它保存的记录根据键排序。默认的是升序排序，也可以指定排序的比较器，
           进行遍历的时候得到的是排序过的记录。


    3.HashMap、LinkedHashMap、ConcurrentHashMap、ArrayList、LinkedList的底层实现。
        1、HashMap是java数据结构中两大结构数组和链表的组合。HashMap底层数组，数组中的每一项又是一个链表。
        程序会先根据key的hashcode（）方法返回值决定该Entry在数组中的
        存储位置，如果该位置上没有元素，就会将元素放置在此位置上，如果两个Entry的key相同，会调用equals，
        返回值是true则覆盖原来的value值，返回false则会形成Entry链，位于头部

        2、ArrrayList的底层实现是数组，在执行add操作时，会先检查数组 大小是否可以容纳新的元素，如果不够就会进行扩容。
        然后会将原来的数据拷贝到新的数组中

        3、LinkedList底层是一个链表，其实现增删改查和数据结构中的操作完全相同，而且插入是有序的

        4、LinkedHashMap的底层结构式是双链表，其他的逻辑处理与HashMap一致，同样没有锁保护，多线程使用时存在风险

        5、ConcurrentHashMap是segment数组结构和HashEntry数组结构组成的，segment在ConcurrentHashMap中充当锁的角色，
        HashEntry用于存储键值对数据。segment的结构是数组 和链表，一个segment中有一个HashEntry，
        每个HashEntry是一个链表结构的元素。对HashEntry中的数据进行修改时，需要先获得它所对应的segment锁。
        每个ConcurrentHashMap默认有16个segment。

    4.迭代器Iterator
        Iterator提供了统一遍历操作集合元素的统一接口，Collection接口实现Iterator接口。
        每个集合都通过实现Iterator接口中的iterator（）方法返回实例，然后对元素进行迭代操作，，但是
        在迭代元素的时候不能使用集合的方法删除元素，否则会抛出异常，可以使用Iterator接口中的remove（）方法进行删除

    5.快速失败（fail-fast）和安全失败（fail-safe）的区别
        Iterator的安全失败是基于对底层集合做拷贝，因此它不受源集合修改的影响。
        util包下的所有集合类都是快速失败的，util.concurren包下面的所有类都是安全失败的。

    6.什么是java序列化？如何实现java序列化
        序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。
        可以对流化后的对象进行读写操作， 也可以将流化后的对象在网络间进行传递。
        序列化的实现：将需要被序列化的类实现Serializable接口，
        该接口没有需要实现的方法，implements Serializable 只是为了标注 该对象时可被序列化的。

    线程、反射、枚举、泛型：

    7.创建线程的3种方式。
        1、继承Thread类

        2、实现Runnable接口

        3、应用程序可以使用Executor框架来创建线程池。

        实现Runnable接口的这种方式是更好的，因为不需要继承Thread类，在应用设计中已经继承了别的对象的情况下，需要多继承
        ，但是java不支持多继承，同时线程池也是非常高效的，很容易实现和使用。

    8.什么是ThreadLocal。
        在面向对象编程中，创建和销毁对象是很耗费时间的，因为创建一个对象要获取内存资源或者其他的资源。
        在java中更是如此，所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象。
        线程池，顾名思义就是事先创建若干个可执行的线程放如到一个池（容器）中，
        需要的时候从池中获取线程不用自行创建，使用完毕后不需要销毁线程而是放回到池中，从而
        减少创建和销毁线程对象的开销。

    9.创建线程池的4种方式。
        java5中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。
        要配置一个线程池是非常复杂的，因此工具类Executors里面提供了一些静态的工厂方法

        来生成线程池：

        1、newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作。
        如果这个唯一的线程因为异常结束，就会有一个新的线程来代替它

        2、newFixedThreadPool：创建一个固定大小的线程池。

        3、newCacheThreadPool：创建一个可缓存的线程池。

        4、newScheduledThreadPool：创建一个大小不限的线程池

    10.线程同步的方法：sychronized、lock、reentrantLock等
        1、sychrnized关键字主要有两种用法：sychrnized方法和sychrnized块。

        sychrnized方法，在方法声明前加入了sychrnized关键字，把需要同步的资源放入到该方法中，
        就能保证这个方法在同一时刻只能被一个线程调用，从而实现了多线程访问的安全性

        sychrnized块，既可以把任意的代码段声明为sychrnized，也可以指定上锁的对象，非常具有灵活性，
        如果一个对象既有同步方法又有同步块，那额当前中的一个同步方法或者同步块被

        线程执行时，这个对象就被锁定了，其他线程无法在此时访问这个对象的同步方法和同步块

        2、Lock：jdk5新增了Lock接口以及他的一个实现类ReentrantLock（重入锁）。Lock（），
        以阻塞的方式来获取锁，如果获取到锁，就立即返回，如果别的线程持有锁，则当前线程等待直到获取到锁返回

        3、ReentranLock

    11.Runnable接口和Callable接口的区别。
        1、Runnable的方法时run（）方法，Callable的方法是call（）

        2、Callable的任务执行后可以返回值，Runnable的任务是不能返回值

        3、call方法可以抛出异常，但是run方法不能抛出异常

    12.wait方法和sleep方法的区别。
        sleep是线程类Thread的方法，导致此线程暂停执行时间，把执行机会给其他的线程，但是监控状态依然保持，到时会自动恢复，
        调用sleep不会释放对象锁

        wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待锁定池，
        只有针对此对象发出notify方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。

    13.分布式环境下，怎么保证线程安全。
        1、时间戳：分布式环境下是无法保证时序的，无论是通过远程接口同步调用或者一部消息，
        很容易造成某些对时序性有要求的业务在高并发时产生错误。对于这问问题，常用的方法是

        采用时间戳的方式。系统A给系统B发送变更时需要带上一个时间戳，B通过与已经存在的时间戳进行变更，这样的方式比较简单，
        关键在于调用的一方要有保证时间戳的时序有效性

        2、串行化：有时候可以牺牲性能和扩张性来使用串行化，满足对数据一致性的需求。

        3、数据库：分布式的环境中共享资源不能 通过
        4、行锁：

        5、统一触发途径：当一个数据可能被多个触发点或多个业务涉及到，就有并发问题产生的隐患，因此
        可以通过前期架构和业务世界尽量统一触发途径，触发途径少一是减少了并发的可能性也有利于并发问题的分析和判断

    14.介绍下CAS(无锁技术)。
        CAS(compare and swap)，即比较并替换，实现并发算法时常用到的一种技术，CAS是通过unsafe类的compareAndSwap方法实现的

        CAS的思想：三个参数，一个当前内存值V，旧的预期值A，即将更新的值B，当且仅当预期值和内存值相同时将内存值修改为即
        将更新的值并返回，否则什么都不做，返回false。

        缺点：即就是ABA问题，也就是如果变量A初次读取的是A，并且在准备赋值的时候检查到它还是A，那能证明它没有被修改过吗？
        很显然是不能的，如果这段时间它被修改为B然后又被

        修改为A，那么CAS就会认为它没有被修改过，针对这种情况，java并发包提供了一个带有标记的原子引用类，
        AtomicStampedReference，它可以通过看着呢会变量值的版本来保证CAS的正确性。

    15.反射的作用于原理。
        简单的说，反射机制其实就是指程序在运行的时候可以获取自身的信息，。如果知道一个 类的名称或者它的一个实例对象，
        就能把这个类的所有方法和变量的信息找出来，如果明确知道
        这个类里的某个方法名和参数个数及类型，还能通过传递参数来运行那个类的方法，这就是反射。
        在java中，class类与java.lang.reflect类库一起对反射的概念提供了支持，该类库包含了了Field、Method以及Construcctor类。

    16.泛型常用特点，List<String>能否转为List<Object>。
        泛型实现了参数化类型的概念，使得我们的代码可以在更多的场景使用。泛型的好处在于在编译时进行类型的安全检查，
        并且在运行的时候所有的转换都是强制的，隐式的，大大的提高了代码的重用率。

        先来回答List<String>能否转为List<Object>的问题，答案是不行的，因为String的list不是Object的list，
        String的list持有String类和其子类型，Object的list持有任何类型的Object，String的list在类型上不等价于Object的list

    17.JNI的使用
    JNI即Java Native Interface的缩写，中文译为“Java本地调用”。通俗的说，JNI是一种实现Java层
    与Native层（C/C++）交互的技术。有时为了追求效率问题，
    或者是使用用native代码编写的函数库，我们就不得不使用JNI接口。




设计模式的6大原则：
    开闭原则：对扩展开放，对修改关闭
    里氏代换原则：
    依赖倒转原则：
    接口隔离原则
    迪米特法则
    合成复用原则：

单例模式：饿汉模式，懒汉模式，枚举模式，Spring中默认配置Bean
    用枚举是最好的，因为枚举类不能被实例化（new），其次它的构造方法模式就是私有的。其实就跟饿汉模式是一样的。

代理模式：AOP底层思想，Spring采用的是JDK动态代码和CGlib代理
    静态代理就是代理类Proxy把需要代理的对象类引用进来，然后调用代理对象的方法，
    但是代理类的好处就是被代理的对象不用关心具体细节，代理类还可以在执行被代理类方法前后添加自己的方法。

    JDK动态代理：代理类实现InvocationHandler，通过反射的方式获取到目标对象实例，然后执行目标对象的方法，当然在执行目标方法的时候也可以添加自己的操作。

    CGlib动态代理：代理类实现MethodInterceptor接口，
    采用的是FastClass机制：为代理类和被代理类各生成一个类，这个类和代理类会被分配一个入参 index（int类型），
    FastClass就是通过这个入参进行调用代理类和被代理类的方法，所有CGLib执行效率要更高。

    优点：能将代理对象和被代理对象分离开，在一定程度上降低了代码的耦合度；起到了保护目标对象和增强目标对象的作用。
    缺点：导致设计的类过多；生成一个代理对象，会导致处理速度变慢；增加了系统的复杂度


委派模式：Spring提供了DispatcherServlet来对请求进行分发



适配器模式：
    在不改变要适配的类的前提下，复用该类；
    让目标类和适配器类解耦
    电压转换的例子；220V->44V

装饰者模式：
    是继承的有力补充，在不改变原有对象的情况下动态的给一个类扩展功能。
    通过继承目标类创建一个抽象类，在建造一个装饰类来继承这个抽象类从而达到装饰目标类的目的；


模板模式：用来解决重复的代码问题
    先构造一个抽象类，把公共的方法和处理流程写在里面。
    子类继承该抽象类，具体细节子类自己内部处理。
    Mybatis源码

    优点：相同的代码和处理逻辑放在父类中，提高了代码的复用性；
        不同处理逻辑放在子类，提供了很好的扩展性。


策略模式：
    先构造一个抽象类或者接口，其中包含要实现的方法。
    每一个策略类实现或者继承它，
    再通过工厂模式，根据传入的参数来决定使用哪种策略类。
    支付的例子；

    优点：符合开闭原则，避免使用多个 if else；可以提高算法的保密性和安全性
    缺点：前提是必须知道所有的策略，才能决定使用哪个策略类；


工厂模式：BeanFactory用来创建对象的实例，贯穿 BF和ApplicationContext接口




建造者模式：


多线程相关面试题：



Spring IOC,AOP原理：

Spring面试相关

Spring Boot 相关

Spring Cloud相关


IO流相关：




腾讯会议
18717762547

servlet和jsp的区别？



1、在每个公司都能学到东西
   技术：看到问题就要去解决问题；
   非技术：看到问题就要去解决问题；帮别人去做东西；把一个简单的东西做到极致。

2、在一家公司如何成长
    这个地方的工作方式；
    把自己的想法如何落地
    资料库：在这家公司学到其他地方学不到的东西
    树立自己的形象：踏实，认真
    以前做得好的东西带过来
    解决上司最想解决的问题-》得知道这个问题是什么？